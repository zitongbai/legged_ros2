  // TODO: make it more readable and beautiful
  // Load RL env configuration from yaml file
  try{
    auto config = YAML::LoadFile(rl_env_cfg_path_);
    // --------------------------------------------------
    // Load Observation terms config
    // --------------------------------------------------
    if (config["observations"] && config["observations"]["policy"]) {
      auto policy = config["observations"]["policy"];
      obs_num_ = 0;
      for(auto it=policy.begin(); it != policy.end(); ++it){
        if (it->second.IsMap()){
          std::string obs_term_name = it->first.as<std::string>();
          RCLCPP_INFO(get_node()->get_logger(), "Adding observation term: %s", obs_term_name.c_str());
          
          double clip = std::numeric_limits<double>::infinity();
          if (it->second["clip"] && !it->second["clip"].IsNull()) {
            clip = it->second["clip"].as<double>();
          }
          
          double scale = 1.0;
          if (it->second["scale"] && !it->second["scale"].IsNull()) {
            scale = it->second["scale"].as<double>();
          }
          ObsFunc obs_func;
          int obs_n = 0;
          try{
            obs_n = find_obs_func_(obs_term_name, obs_func);
          } catch (const std::exception & e) {
            RCLCPP_ERROR(get_node()->get_logger(), "Failed to parse observation term '%s': %s", obs_term_name.c_str(), e.what());
            return controller_interface::CallbackReturn::ERROR;
          }
          obs_num_ += obs_n;
          obs_terms_.emplace_back(ObsTerm{obs_term_name, obs_func, obs_n, clip, scale});
        } // end if
      } // end iterating policy's terms
      obs_tensor_ = torch::zeros({1, obs_num_}, torch::kFloat64);
    } else {
      RCLCPP_ERROR(get_node()->get_logger(), "No observations or policy defined in the config file.");
      return controller_interface::CallbackReturn::ERROR;
    }
    // --------------------------------------------------
    // Load Action terms config
    // --------------------------------------------------
    // clip and scale
    std::cout<< "Loading action terms configuration..." << std::endl;
    if (config["actions"].IsDefined() && config["actions"]["joint_pos"].IsDefined()){
      auto node = config["actions"]["joint_pos"];
      if (node["clip"].IsDefined() && node["clip"].IsScalar()) {
        action_term_.clip = node["clip"].as<double>();
      } else {
        action_term_.clip = std::numeric_limits<double>::infinity();
      }
      if (node["scale"].IsDefined() && node["scale"].IsScalar()) {
        action_term_.scale = node["scale"].as<double>();
      } else {
        action_term_.scale = 1.0;
      }
    } else {
      RCLCPP_ERROR(get_node()->get_logger(), "No actions or actions.joint_pos defined in the config file.");
      return controller_interface::CallbackReturn::ERROR;
    }
    // kp and kd
    std::cout << "Loading action terms stiffness and damping configuration..." << std::endl;
    action_term_.kp.resize(joint_names_.size(), 0.0);
    action_term_.kd.resize(joint_names_.size(), 0.0);
    if (config["scene"]["robot"]["actuators"].IsDefined()){
      auto node = config["scene"]["robot"]["actuators"];
      for(auto it=node.begin(); it!=node.end(); ++it){
        std::vector<std::string> joint_names_expr = it->second["joint_names_expr"].as<std::vector<std::string>>();
        std::cout << "xxxxxx" << std::endl;
        for(const std::string & expr: joint_names_expr){
          std::regex pattern(expr);
          for(size_t i=0; i<joint_names_.size(); ++i){
            if (std::regex_match(joint_names_[i], pattern)) {
              action_term_.kp[i] = it->second["stiffness"].as<double>();
              action_term_.kd[i] = it->second["damping"].as<double>();
            }
          }
        }
      }
    } else{
      RCLCPP_ERROR(get_node()->get_logger(), "No scene.robot.actuators defined in the config file.");
      return controller_interface::CallbackReturn::ERROR;
    }
    // default pos
    std::cout << "Loading default joint positions configuration..." << std::endl;
    if (config["scene"]["robot"]["init_state"]["joint_pos"].IsDefined()){
      auto node = config["scene"]["robot"]["init_state"]["joint_pos"];
      for(auto it=node.begin(); it!=node.end(); ++it){
        const auto & jnt_expr = it->first.as<std::string>();
        const auto & jnt_pos = it->second.as<double>();
        std::regex pattern(jnt_expr);
        for(size_t i=0; i<joint_names_.size(); ++i){
          if (std::regex_match(joint_names_[i], pattern)) {
            action_term_.default_joint_pos[i] = jnt_pos;
          }
        }
      }
    } else {
      RCLCPP_ERROR(get_node()->get_logger(), "No scene.robot.init_state.joint_pos defined in the config file.");
      return controller_interface::CallbackReturn::ERROR;
    }
  } catch (const std::exception & e) {
    RCLCPP_ERROR(get_node()->get_logger(), "Failed to load RL config file: %s", e.what());
    return controller_interface::CallbackReturn::ERROR;
  }

  // Print info loaded from yaml
  std::cout << "------------------------------------------------------" << std::endl;
  std::cout << "RL Environment Configuration:" << std::endl;
  std::cout << "  Observations:" << std::endl;
  for (const auto& term : obs_terms_) {
    std::cout << "    - " << term.name << ": " << term.obs_num << " dimensions, "
              << "clip: " << term.clip << ", scale: " << term.scale << std::endl;
  }
  std::cout << "  Actions:" << std::endl;
  std::cout << "    - Joint Position: clip: " << action_term_.clip
            << ", scale: " << action_term_.scale << std::endl;
  std::cout << "    - Joint Stiffness and Damping:" << std::endl;
  for (size_t i = 0; i < joint_names_.size(); ++i) {
    std::cout << "      - " << joint_names_[i] << ": "
              << "Kp: " << action_term_.kp[i]
              << ", Kd: " << action_term_.kd[i]
              << ", Default Pos: " << action_term_.default_joint_pos[i] << std::endl;
  }
  std::cout << "------------------------------------------------------" << std::endl;